\chapter{Background}
\label{cha:background}
%\textit{Detailed explanation of the problem and its scope: starting from a practical description, a formalization of the entities involved and what they want to achieve. 2 examples (deliveries with couriers and port exchanges). Then, the intentions of the company I have worked for.}

All logistic processes involve the exchange of goods between entities that do not fully trust each other. For example, let us consider a very common scenario: a delivery by a courier that includes a intermediate stop. This can be the porter of a building, or an authorized post office. What usually happens is that when the parcel arrives the receiver testifies with their signature (on paper or on an electronic device) that the exchange has occurred. However, this is not always true, because not all deliveries include this possibility or because the persons directly performing the exchange do not fully respect the protocol. As a result, the process is vulnerable: a hand-written signature is often counterfeitable and when it is not even present, it is possible to generate a ``my word against yours'' debate.

This problem becomes worse when it includes more steps: this happens, for example, in complex systems of organizations, people, activities employed in the supply chain sector: here the handovers are even more articulated and it is important to guarantee a successful outcome of the processes, that are crucial for the companies involved. A series of signatures can be a solution, but, as aforementioned, several things can go wrong.

Who has not been taken into consideration yet is the final recipient. They know nothing about the events happening and they could only be notified autonomously by one of the entities involved, whom they would have to trust. 

Formalizing, the typical scenario is the following. We have a sender \textit{S} and a final recipient \textit{R}. \textit{S} wants to send \textit{R} a particular good, \textit{G}. To perform the exchange, \textit{S} will designate a certain route that involves \textit{n} intermediate stops ($I_1, I_2, ..., I_n$) and will instruct \textit{m} dealers ($D_1, D_2, ..., D_m$) that will take care of each part of the delivery. From a theoretical point of view, nothing forbids to have two identical dealers $D_i$ and $D_j$. Indeed, as we will see later, we are not really interested in the dealers themselves, but more in the companies that these dealers work for. We assume that \textit{S} decides the route, or at least, knows the various stops needed. We would like to find a model able to register precisely each handover, by making use of secure techniques that do not allow counterfeiting or fraud: each entity should be protected against a potential malicious one. Finally, \textit{R} should be able to monitor the events about \textit{G}, in order to check the progresses.

During my internship at \textsc{Spindox Labs}, we tried to investigate a solution to this problem. We started from the wide experience that the company had with tracking devices, trying to understand if one of them could be applicable to this case. After a thorough analysis of the alternatives, fully reported in \ref{sec:tracking}, we found a good solution, satisfying our needs. After this, the most significant part of our research involved the study on the architecture that our system required. We wanted to find an innovative solution that eliminated any centralized authority, because we could not introduce one in the problem: many entities at the same level, without a supervising one. 

\section{Decentralization}
\label{sec:decentralization}
%\textit{Why decentralization can be the solution, how it differs from a traditional approach. The blockchain, with its hype, as a valid alternative. Deep explanation of what it is etc.}

Considering this, we tried to find a decentralized alternative: unlike traditional architectures, that usually present a single element providing all the information for the service and practically having control, a typical distributed network shares knowledge between many nodes, therefore excluding a central point.

Centralization versus decentralization is a battle that does not have a definite winner. The Internet has seen several attempts of decentralize some services, like DNS and social networks, but the truth is that, in many situations, the benefits of keeping a central entity are outperforming those of the correspondent distributed alternatives \cite{Montresor_Permissionless}. However, there are still some cases in which a P2P network is a valid solution, especially when there are hard requirements like privacy, anti-censorship and scalability. Despite their advantages, in fact, centralized architectures always present a single point of failure, with all its consequences.

When in 2008 the mysterious Satoshi Nakamoto published the Bitcoin paper \cite{bitcoin}, a particular type of distributed network became extremely popular: the blockchain. The author proposed ``a purely peer-to-peer version of electronic cash'', with the aim of introducing a payment system based on a crypto-currency, without intermediaries but still reliable and secure against typical attacks such as double spending. This problem may arise for two reasons. The first is that crypto-currencies have no watermarks to prevent the unauthorized production of money: consequently, it is in principle possible to copy one coin and spend it twice. The second is a direct disadvantage of a distributed system: physiologically there are propagation delays to be handled in order to correctly distinct and validate the right transactions. More generally, distributed networks need to implement a protocol to establish consensus between nodes.
Bitcoin combines existing technologies in a sophisticated way, to solve its fundamental problems. Without examining in depth all these mechanisms, let us concentrate on how transactions are stored: using a blockchain.

The blockchain itself is just a data structure: as the name suggests, it is composed by blocks and each block contains transactions. These transactions are defined with a precise grammar, that obviously depends on the type of application. In Bitcoin, for example, transactions respect the (simplified) form ``the result of transaction $T_i$ is used as input to send $x$ BTC to $A$, with $y$ fee'', where $A$ is the public key of the recipient. Beyond the grammar, to implement a blockchain there is the need of a function to validate transactions. Evidently, the previous sample transaction will be refused, if the sender does not have the rights to use the output of $T_i$. More precisely, Bitcoin uses a measure called proof-of-work, in order to not only include a control on the actual validity of the transactions, but also to require a strong computational effort to approve a block. This is a crucial element to improve reliability and contrast the possibility of subverting the network with sybil attacks. 
% non mi piace, non si spiega bene la proof-of-work, non so quanto abbia senso fare un riferimento cos√¨ velato

What makes the blockchain different from other data structures are two properties. First, it is distributed: every node of the network has its own copy of a ``ledger'', that is kept consistent and up to date with gossip protocols. Second, the way in which these blocks are linked: each one contains the hash fingerprint of the previous. As a result of these, once data is inserted in a block it impossible to change it. In practice, changing a transaction would mean recalculating the hash value of all the blocks succeeding the modified one, replacing the fingerprint and convincing all the network that the new copy is the one that should be used. This is impossible, unless one controls more than half of the overall computing power. Immutability is the first and fundamental property of the blockchain, that makes it a good solution to store money exchanges: obviously, crypto-currency designers do not want to allow the possibility of modifying any of the validated transactions.

The Bitcoin system showed the world the great potential of the blockchain. After its success, a number of other similar crypto-currencies were launched, with the so called ``initial coin offerings'', generating a new business for investors and speculators. A lot of hype is still surrounding this technology, that in any case presents some disadvantages and it is surely not the right solution for every problem. 

Analyzing again our case, this technology seems to be a suitable solution. Handovers can correspond to the transactions, the goods can be our ``coins'' and the entities of the system can be the participants of the network, submitting exchanges. Essential requirements such as reliability and permanency of transactions would be guaranteed by design. In section \ref{sec:arch} we will discuss better this approach.

